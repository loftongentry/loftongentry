import { useEffect, useRef } from "react"
import * as d3 from 'd3'

const RunGraph = ({ data }) => {
  const svgRef = useRef()

  useEffect(() => {
    //Taking the runData returned from MongoDB and creating a new data object that is better for displaying my data on a graph
    const chartData = data.map(item => ({
      date: item.date,
      avgPace: item.avgPace,
    }))

    chartData.forEach(o => { o.date = new Date(o.date) })

    const width = 360
    const height = 400

    const svg = d3.select(svgRef.current)

    //Maps a continuous time domain to a continuous output range, such as mapping a date value to a position along a time axis
    const x = d3.scaleTime()
      .range([0, width])
      .domain(d3.extent(chartData, d => d.date))
      .nice()

    //Maps a continuous input domain to a continuous output range such a mapping a data value to a position along an axis or pixel size
    const y = d3.scaleLinear()
      .range([height, 0])
      .nice()

    //creates a new array called values that contains all the keys of the first object in the chartData array except for the key 'date'. (The only other key is avgPace)
    const values = Object.keys(chartData[0]).filter(key => key !== "date");

    //Sets the domain of the y-scale to the minimum and maxiumum values found (In this case it is only avgPace, but it can be used for multiple keys)
    y.domain([
      d3.min(chartData, d => d3.min(values, value => d[value])),
      d3.max(chartData, d => d3.max(values, value => d[value]))
    ])

    //Create a line generator function with x coordinate of each data point to be average pace and y-coordinate to be date
    const line = d3.line()
      .x(d => x(d.date))
      .y(d => y(d.avgPace))

    //Maps over the array of keys in 'values' to create an array of line objects
    const paths = values?.map(value => {
      //Creates an object for each 'value' which contains a 'value' key with the name of the value and a 'path' key with a D3 selection of a new 'path' element created on the 'svg' element
      return {
        value: value,
        path: svg
          .append('path')
          .datum(chartData)
          .attr('fill', 'none')
          .attr('stroke', 'steelBlue')
          .attr('stroke-width', 1.5)
          //Sets the 'd' attribute of the path element to the line generated by the line function for the current value
          .attr('d', line.y(d => y(d[value])))
      }
    })

    //Generates a horizontal axis with tick marks and labels based on the x scale that was previously defined and appends it to the bottom of the SVG
    svg
      .append('g')
      .attr('transform', `translate(0, ${height})`)
      .call(d3.axisBottom(x))

    //Generates a vertical axis with tick marks and labels based on the y scale that was previously defined and appends it to the left side of the SVG
    svg
      .append('g')
      .attr('transform', `translate(20, 5)`)
      .call(d3.axisLeft(y))

  }, [data])


  return (
    <svg ref={svgRef}>

    </svg>
  )
}

export default RunGraph